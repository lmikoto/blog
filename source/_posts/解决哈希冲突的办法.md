---
title: 解决哈希冲突的办法
urlname: zonq2g
date: '2020-12-19 11:29:02 +0800'
tags: []
categories: []
---

## 产生哈希冲突的原因

由于哈希函数计算的范围是无限的，而计算后的结果范围是有限的，因此总会存在不同的数据计算得出的值是相同的。这就是哈希冲突。

## 解决办法

### 开放定址法

开放定址法也称为再散列，从发生冲突的那个单元开始，按照一定的次序，从哈希表里面找到一个空闲的单元，将对应的元素放入其中。
![](/images/f338bfcac34e7f2121c9b9eee64efede.svg)
其中 H(key)为哈希函数, length 为哈希表的长度，Di 为增量序列，增量序列的计算方式不一样，对应的散列方法也不一样。主要有以下三种

#### 线性探查法

![](/images/a1dec2be07c73a078b1fcd0d7ce70b62.svg)
发生冲突时，顺序查看表中的下一个单元，直到找到空单元，或者遍历全表没找到。

#### 平方探查法

![](/images/20752cdc978b3ca30e6708d1412ea9e4.svg)

#### 伪随机探测再散列

Di = 伪随机序列
建立一个伪随机序列，比如(i + 10)%length

### 链地址法

将哈希值相同的元素放到一个链表中，java 的 HashMap 正式采用这种方式解决哈希冲突

### 再哈希法

同时构造多个不通的哈希函数，日过第一个发生冲突，就用第二个，直到不冲突或者哈希函数用完

### 公共溢出区

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区
